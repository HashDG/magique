\input texinfo @c -*- texinfo -*-
@c %** start of header
@setfilename rapport.texi
@setcontentsaftertitlepage
@settitle Rage
@setchapternewpage odd
@afourpaper
@c %** end of header

@documentlanguage fr
@documentencoding ISO-8859-1

@ifinfo
Copyright (c) 2001 Patrice Boulanger
@end ifinfo

@titlepage 
@title Rage - @emph{Reckoner AGEnts}
@subtitle Un @emph{framework} de calcul distribu@'e orient@'e agents
@subtitle @code{http://www.lifl.fr/~secq/projects/rage/site}
@author Patrice Boulanger - DESS TIIR Ann@'ee 2000/2001
@author Projet technique
@end titlepage

@unnumbered Statut de ce document/Copyright
@c @vskip 0pt plus 1filll
Copyright @copyright{} 2001 Patrice Boulanger

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that this section
entitled "Copyright" is included exactly as in the original, 
and provided that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@c -------------------------------------------------- Remerciements

@unnumbered Remerciements

Je remercie particuli@`erement Yann Secq@footnote{secq@@lifl.fr, 
@code{http://www.lifl.fr/~secq}} du laboratoire 
SMAC@footnote{Syst@`emes Multi Agents Coop@'eratifs, 
@code{http://www.lifl.fr/SMAC}} pour la confiance qu'il m'a accord@'e en me 
proposant ce projet.@

Je remercie aussi Monsieur Jean-Claude Marti@footnote{marti@@lifl.fr}, 
responsable du DESS TIIR.

@c -------------------------------------------------- Resume

@unnumbered R@'esum@'e

Les utilisateurs de l'outil informatique demandent de plus en plus de puissance
de calcul. Il en a toujours @'et@'e ainsi pour les physiciens, les chimistes ou
les math@'ematiciens qui veulent simuler des mod@`eles demandant de plus en 
plus de ressources en termes de temps d'ex@'ecution ou de m@'emoire. De plus, 
de nouvelles disciplines telles que le @emph{data-mining} sont apparues et, 
avec elles, les acteurs du secteur @'economique sont devenus de grands 
consommateurs de ressources informatiques.@

Pour r@'epondre @`a ce besoin croissant de puissance, les utilisateurs ont 
principalement deux solutions. La premi@`ere consiste @`a 
se doter d'un super-ordinateur, disposant de plusieurs processeurs reli@'es par
un r@'eseau sp@'ecialis@'e hautement performant et dot@'e de beaucoup de 
m@'emoire. Cette solution pose tout de m@^eme un probl@`eme de taille: ce genre
de machine co@^ute extr@^emement ch@`ere. De plus, elle n@'ecessite des 
personnes qualifi@'ees pour l'installation, la maintenance et le 
d@'eveloppement.@

La seconde solution se base sur une id@'ee simple: relier plusieurs machines
"traditionnelles" par un r@'eseau et partager le probl@`eme entre les 
diff@'erents postes. Cette solution, m@^eme si elle est moins performante, 
est particuli@`erement int@'eressante pour les universit@'es ou les entreprises
qui disposent d@'ej@`a d'un parc important de machines reli@'ees en r@'eseau
et dont la puissance de calcul est sous utilis@'ee (nuit, week-end, 
vacances ...).
De plus, la perc@'ee d'Internet a permis @`a des projets mettant plusieurs
milliers de machines r@'eparties @`a travers le monde de voir le jour 
pour coop@'erer sur des probl@`emes (@emph{challenges}) demandant 
@'enorm@'ement de puissance de calcul. Nous citerons par exemple les projets 
SETI@footnote{http://www.seti.org/}) (@emph{Search for Extra Terrestrial 
Intelligence}) ou 
@emph{distributed.net}@footnote{http://www.distributed.net}).@

Voyons les probl@`emes que posent cette solution. Tout d'abord, il faut prendre
en compte l'h@'et@'erog@'en@'eit@'e des machines et des syst@`emes 
d'exploitation existants. Le fait de distribuer une application fait aussi 
apparaitre des probl@`emes dans l'@'ecriture de l'application. 
Le d@'eveloppeur doit en effet se pr@'eoccuper d'aspects qui n'appartiennent
pas au cadre du probl@`eme et doit traiter les probl@`emes de communications 
r@'eseau ou de gestion des erreurs distantes.@

C'est dans ce cadre que se situe Rage. Il s'agit de proposer un cadre de 
travail pour les d@'eveloppeurs d'applications distribu@'ees leur 
permettant de mettre au point rapidement et simplement des applications 
fiables et efficaces. Son originalit@'e est de s'appuyer sur 
le syst@`eme multi-agents Magique, d@'evelopp@'e @`a l'universit@'e de 
Lille 1 par l'@'equipe SMAC. De plus, Rage est d@'evelopp@'e en Java, ce qui
lui permet de s'abstraire des probl@`emes li@'es aux diff@'erentes 
plateformes existantes. 

L'objectif de ce document est de d@'ecrire l'architecture et les concepts 
propres @`a Rage ainsi que de faciliter la prise en main de ce 
@emph{framework}. 
Nous commencerons par expliquer les concepts d'agents et de syst@`emes 
multi agents et, en particulier, Magique. Viendra ensuite la description
de l'architecture de Rage. Nous concluerons enfin par
les exemples qui ont permis d@'evaluer et de valider le @emph{framework}.

@c -------------------------------------------------- Chapitre 1

@chapter Agents, Syst@`emes Multi-Agents et Magique

@section Qu'est ce qu'un agent ?

On trouve de nombreuses d@'efinitions sur la notion d'agents. On peut 
d@'efinir de mani@`ere abstraite un agent comme une @emph{entit@'e 
individualis@'ee}, identifi@'ee par un @'etat et une @'evolution et 
@emph{qui peut interagir avec d'autres agents} (interactions sociales) 
ou avec des ensembles de donn@'ees et de processus ext@'erieurs 
(environnement).
On peut cependant pr@'eciser cette notion en d@'efinissant, de mani@`ere
plus concr@`ete, un agent comme un @emph{programme autonome et communiquant} 
avec d'autres agents et avec son environnement.@ 

@section Les syst@`emes Multi Agents

Un syst@`eme multi-agents est un mod@'ele informatique compos@'e d'entit@'es 
artificielles qui communiquent entre elles et agissent dans un environnement.
En d'autres termes, un SMA est la r@'eunion d'agents communiquant entre
eux et coop@'erant pour r@'esoudre un probl@`eme. 
Avec les d@'eveloppements actuels des r@'eseaux informatiques, les SMA 
abordent tout naturellement les probl@'ematiques de r@'epartition et de 
distribution.

@section Magique (@strong{M}ulti @strong{AG}ents hi@'erarch@strong{IQUE}s)

Magique@footnote{http://www.lifl.fr/SMAC/projects/magique} est un SMA d@'evelopp@'e 
@`a l'universit@'e Lille 1 par l'@'equipe de recherche SMAC@footnote{Syst@`emes 
Multi Agents Coop@'eratifs}. Il a @'et@'e enti@`erement d@'evelopp@'e en Java.@

Le but principal de Magique est de fournir un @emph{framework} pouvant @^etre
rapidement pris en main pour mettre en place des applications multi-agents.
Sa principale originalit@'e r@'eside dans le mod@`ele hi@'erarchique
qu'il d@'efinit et qui fournit certaines facilit@'es de d@'eveloppement.@

@subsection Les agents Magique

Les agents peuvent @^etre facilement d@'evelopp@'es en utilisant la notion de
@emph{skill} de Magique. Cette notion de @emph{skill} (comp@'etence) 
pr@'esente un moyen simple d'obtenir l'@'evolutivit@'e et la cr@'eation 
dynamique d'agents.
Voici un exemple de cr@'eation d'agent: @

@example
import fr.lifl.magique.*;
...

Agent agent = new Agent("myAgent"); // creation de l'agent

platform.addAgent(agent); // ajout de l'agent a une plateforme Magique

agent.addSkill(new SkillOne(agent));   //
agent.addSkill(new SkillTwo(agent));   // ajout de comp@'etences
agent.addSkill(new SkillThree(agent)); //

// joindre la hierarchie       
myAgent.connectToBoss("Boss");
@end example

Une @emph{skill} est d@'efinie comme un composant (@emph{i.e.} un objet Java) dont
les m@'ethodes d@'eclar@'ees publiques sont accessibles par l'agent qui l'a apprise.

@subsection Le mod@`ele hi@'erarchique

Dans Magique, un syst@`eme multi-agents est d@'efini comme un ensemble de 
groupes. Un groupe est form@'e d'agents sp@'ecialis@'es, chacun d'entre eux
@'etant autonomes et disposant des capacit@'es de base pour communiquer et agir. 
A la base, un agent ne connait que son superviseur, le nombre de niveaux de 
supervision n'@'etant pas limit@'e. Un superviseur connait donc tous les agents
qui sont dans son groupe ainsi que son propre superviseur. 
Le sch@'ema suivant r@'esume cette structure:

@image{tree, 13cm, }

Dans cette hi@'erarchie, chaque agent superviseur a connaissance de plusieurs
@'el@'ements:

@itemize @bullet
@item
les membres de son @'equipe et, si certains membres sont eux-m@^emes des
superviseurs, le nom des membres de ces sous-@'equipes;
@item
les capacit@'es de tous les agents plac@'es sous lui dans la hi@'erarchie;
@item
pour une t@^ache donn@'e, il est capable de d@'etermin@'e qui, dans son 
@'equipe, peut r@'ealiser cette t@^ache.
@end itemize

Le principe de traitement d'une t@^ache par un agent Magique est le suivant
(les choses se d@'eroulent dans cet ordre):

@enumerate
@item
si l'agent a la possibilit@'e de traiter la t@^ache, il le fait;
@item
si quelqu'un dans son @'equipe (ou dans l'une des sous-@'equipes) est capable 
de traiter la t@^ache, il lui transmet;
@item
sinon, il transmet la t@^ache @`a son superviseur. Si l'agent est la racine
de la hi@'erarchie, la t@^ache reste bloqu@'ee jusqu'@`a que la comp@'etence
ait rejoint la structure.
@end enumerate

Les t@^aches peuvent @^etre des ordres (proc@'edures) ou des questions 
(fonctions). Les t@^aches sont donc des m@'ethodes au sens de Java@footnote{Il 
faut noter que les agents sont des objets @emph{threaded}. A chaque fois 
qu'un agent doit g@'erer une t@^ache, il applique la m@'ethode d@'ecrite 
pr@'ecedemment. Chaque t@^ache est g@'er@'ee par un @emph{thread} s@'epar@'e.
Des m@'ecanismes d'exclusion et de synchronisation peuvent donc se r@'ev@'eler
n@'ecessaires.}.@

Il existe essentiellement trois types de primitives pour le traitement des 
requ@^etes:

@itemize @bullet
@item
@strong{@code{perform}} pour les requ@^etes de type ordre;
@item
@strong{@code{ask}} pour les requ@^etes asynchrones;
@item
@strong{@code{askNow}} pour les requ@^etes synchrones.
@end itemize

Par exemple,

@example
perform("methodName", arg1, arg2);
@end example

permet d'appeler la proc@'edure @code{public void methodName(arg1, arg2)}. 

Si la m@'ethode renvoie un r@'esultat sous la forme d'un objet d'une classe
particuli@`ere, on utilisera par exemple:

@example
AClassType result = (AClassType) askNow("functionName", arg1, ...);
@end example

Les remarques suivantes sont importantes:
@itemize @bullet
@item
les m@'ethodes @code{methodName} et @code{functionName} doivent @^etre 
des m@'ethodes publiques d'au moins un agent du syst@`eme;
@item
les argument @emph{argi} doivent @^etre s@'erialisables;
@end itemize

On remarquera qu'il n'est pas n@'ecessaire de savoir qui est capable de
r@'ealiser la t@^ache en question. Il suffit de lancer l'appel dans la 
hi@'erarchie d'agents (appel @`a la cantonnade). Cependant, il est possible 
de nommer l'agent devant traiter la demande, m@^eme si cette solution est 
moins @'el@'egante.

@c -------------------------------------------------- Chapitre 2

@chapter Rage, architecture et concepts

Dans ce chapitre, nous allons rentrer dans les d@'etails de Rage. Nous 
commencerons par exposer la hi@'erarchie mise en place. Ensuite nous 
aborderons quelques concepts indispensables pour utiliser Rage en tant 
que d@'eveloppeur. Enfin, nous d@'ecrirons le r@^ole et les comp@'etences 
de chaque agent. 

@section La hi@'erarchie Rage

Rage est b@^ati au-dessus du SMA Magique d@'ecrit au chapitre pr@'ec@'edent. 
Un point essentiel dans la conception de Rage f@^ut donc la mise au point 
de la hi@'erarchie Magique utilis@'ee par Rage.@

En tant que syst@`eme de calcul distribu@'e, Rage doit satisfaire plusieurs 
crit@`eres:

@itemize @bullet
@item 
g@'erer automatiquement de la r@'epartition de charge entre les 
diff@'erents agents responsables des calculs;
@item
proposer un moyen de stocker les r@'esultats des calculs de mani@`re @`a ce
que chaque partie du @emph{framework} puisse y avoir acc@'es;
@item
pr@'evoir des m@'ecanismes automatiques de tol@'erance aux pannes.
@end itemize

En partant de ces exigences, nous sommes arriv@'e au mod@`ele de hi@'erarchie
suivant:

@image{hierarchie, 12cm, }

Ce sch@'ema fait apparaitre un point important. Ce mod@`ele est en effet 
s@'epar@'e en deux parties. La partie haute repr@'esente la partie utilisateur,
qui d@'epend de l'application. La partie basse est le syst@`eme 
Rage dont l'architecture reste constante au nombre d'agents pr@'es. L'agent 
abritant l'application vient donc se connecter @`a la racine de
la hi@'erarchie, qui lui fournit ainsi un moyen de communication avec le reste
du syst@`eme.@

@section Les clients Rage

@subsection Les t@^aches

La t@^ache est l'@'el@'ement de calcul de l'application pouvant @^etre 
distribu@'e. Chaque t@^ache poss@'ede un nom unique pour une application
donn@'ee.
A une t@^ache est associ@'e un @code{ReckonerAgent} qui assure l'int@'egration 
de la t@^ache dans le @emph{framework} (la t@^ache est un objet et non un 
agent). 
Ceci permet @`a la t@^ache d'avoir acc@'es aux possibilit@'es de communication 
du @emph{framework} (appel de comp@'etences) notamment pour connaitre le 
r@'esultat d'autres t@^aches ou pour communiquer avec elles.@

L'interface d'une t@^ache est la suivante:

@example
public interface Task extends Serializable @{
    
    public boolean init();

    public void launch();

    public void compute();

    public boolean suspend();

    public boolean mustDie(Object cond);

    public void die();
   
    public Result getResult();

    public boolean finished();

    public double percent();

    public String getFactoryID();

    public void setFactoryID(String id);

    public String getTaskID();

    public void setAgent(Agent agent);

    public int getTimeout();   
@}
@end example

@itemize @bullet 
@item 
@code{public boolean init()}: initialise la t@^ache. Renvoie @code{true}
si l'initialisation a r@'eussie, @code{false} sinon;
@item 
@code{public void launch()}: d@'emarre le calcul de la t@^ache, @emph{i.e.}
appelle @code{compute} tant que @code{finished()} renvoie @code{false};
@item 
@code{public void compute()}: r@'ealise une partie du calcul imparti @`a la
t@^ache. Cette m@'ethode est appel@'ee tant que la m@'ethode @code{finished()}
renvoie @code{false};
@item 
@code{public boolean suspend()}: suspend la t@^ache. Le calcul reprendra 
apr@`es un appel @`a la m@'ethode @code{launch};
@item 
@code{public boolean mustDie(Object cond)}: renvoie @code{true} si la t@^ache 
doit @^etre arr@^et@'ee. La t@^ache peut se servir de l'objet @code{cond} pour
d@'eterminer si elle doit s'arr@^eter ou non; 
@item 
@code{public void die()}: met fin @`a la t@^ache. Aucun r@'esultat n'est 
pris en compte (l'appel @`a cette m@'ethode doit @^etre interpr@'et@'e 
comme un abandon de la t@^ache);
@item 
@code{public Result getResult()}: renvoie le r@'esultat du calcul de la 
t@^ache;
@item 
@code{public boolean finished()}: renvoie @code{true} si le calcul de cette
t@^ache est termin@'e;
@item 
@code{public double percent()}: renvoie le facteur d'avancement du calcul de 
cette t@^ache;
@item 
@code{public String getFactoryID()}: renvoie l'identificateur de la 
@emph{factory} qui a produit cette t@^ache;
@item 
@code{public void setFactoryID(String id)}:
permet de fixer l'identificateur de la @emph{factory} ayant produit cette 
t@^ache;
@item 
@code{public String getTaskID()}: renvoie l'identificateur de cette t@^ache. 
Le format de cette identificateur est @emph{factoryId}.@emph{task_name};
@item 
@code{public void setAgent(Agent agent)}: fixe l'agent qui abrite cette 
t@^ache;
@item 
@code{public int getTimeout()}: renvoie le nombre de secondes au bout 
desquelles la t@^ache doit @^etre consid@'er@'ee comme perdue et doit @^etre
relanc@'ee @`a nouveau.
@end itemize

Plut@^ot que d'impl@'ementer cette interface, il est fortement conseill@'e aux
d@'eveloppeurs souhaitant utiliser Rage d'@'etendre la classe 
@code{AbstractTask} qui impl@'emente la plupart des m@'ethodes ci-dessus. 
Il ne reste en fait au d@'eveloppeur qu'@`a @'ecrire les m@'ethodes 
@code{compute}, @code{finished} et @code{percent}. 

Si le d@'eveloppeur souhaite r@'eellement impl@'ementer l'interface ci-dessus,
il lui faudra respecter la s@'emantique attach@'ee @`a chaque m@'ethode. 
En particulier, le cycle de vie d'une t@^ache doit correspondre au graphe 
suivant: 

@image{task, 8cm, }

Il ne devra pas oublier de renvoyer le r@'esultat du calcul lorsque la t@^ache
sera termin@'ee. Il lui faudra enfin s'assurer que les t@^aches sont bien 
s@'erialisables.

@subsection Le r@^ole @emph{TaskFactory}

Dans le mod@`ele de Rage, une @emph{factory} est l'@'el@'ement produisant
les diff@'erentes t@^aches du calcul. Elle est appel@'ee par le 
@code{TaskManager}. Son interface est la suivante:

@example
public interface TaskFactory @{

    public boolean hasNext();

    public Task next();

    public String getFactoryID();
@}
@end example

@itemize @bullet
@item
@code{public boolean hasNext()}: renvoie @code{true} tant que la @emph{factory}
a encore des t@^aches @`a produire;
@item
@code{public Task next()}: renvoie la prochaine t@^ache @`a calculer;
@item
@code{public String getFactoryID()}: renvoie l'identificateur de cette 
@emph{factory}.
@end itemize

@subsection Le r@^ole TaskManager

Le @code{TaskManager} est l'agent qui encapsule l'algorithme de l'application.
Il est totalement sp@'ecifique @`a l'application, toute libert@'e est donc 
laiss@'ee @`a l'utilisateur dans sa conception.

@section Les agents du @emph{framework} Rage

@subsection Le r@^ole Boss

Il s'agit d'un agent vide dont la seule raison d'@^etre est de faire le lien
entre les diff@'erents agents.

@subsection Le r@^ole TaskDispatcher

Cet agent re@,{c}oit les t@^aches venant du @code{TaskManager}. Il les 
distribue ensuite aux @code{PlatformManager} qui les demandent. Il g@`ere 
donc deux files: une pour les t@^aches en attente et une autre pour celles 
qui ont @'et@'e distribu@'e. De plus, il v@'erifie r@'eguli@`erement que le 
d@'elai de garde (@emph{timeout}) de chaque t@^ache n'a pas @'et@'e 
d@'epass@'e. Dans le cas contraire, il replace la t@^ache dans la liste des 
t@^aches en attente, ce qui permettra de la relancer plus tard.

@itemize @bullet

@item
@code{public String taskDispatcherName()}: renvoie le nom de l'agent d@'etenant
cette comp@'etence. Cette m@'ethode est invoqu@'ee par les 
@code{PlatformManager} pour leur permettre de connaitre automatiquement le 
@code{TaskDispatcher};

@item
@code{public void addNewTask(WrapperTask wrapperTask)}: d@'epose une nouvelle
t@^ache dans le @code{TaskDispatcher}. Cette t@^ache est plac@'ee dans la file 
des t@^aches en attente. C'est la m@'ethode qui doit @^etre appel@'ee par les
@code{TaskManager} pour distribuer leurs t@^aches;

@item
@code{public Integer waitingTasks()}: renvoie le nombre de t@^aches en attente
dans ce @code{TaskDispatcher};

@item
@code{public Integer runningTasks()}: renvoie le nombre de t@^aches qui ont
@'et@'e distribu@'e;

@item
@code{public Task getNextTask()}: renvoie la prochaine t@^ache devant @^etre
calcul@'ee. Cette m@'ethode est utilis@'ee par les @code{PlatformManager} pour
obtenir les t@^aches; 

@item
@code{public void completedTask(String taskId)}: indique au 
@code{TaskDispatcher} que la t@^ache @code{taskId} a @'et@'e calcul@'e. 
Celui-ci la supprime donc de ses files d'attente. Cette m@'ethode est 
appel@'ee par les @code{ResultRepository} lorsqu'ils re@,{c}oivent une 
nouvelle t@^ache @`a stocker.
@end itemize

@subsection Le r@^ole ResultRepository

Ces agents sont la "m@'emoire du syst@`eme". Ils re@,{c}oivent les objets
de type @code{Result} @'emis par les t@^aches @`a leur terminaison. Les
@code{ResultRepository} pr@'esents dans la hi@'erarchie enregistrent tous
les m@^eme donn@'ees. On obtient donc une r@'eplication de la base de 
donn@'ee des r@'esultats. Ceci procure deux avantages:
@enumerate
@item
si un @code{ResultRepository} tombe, les autres sont toujours pr@'esents. 
Cela am@'eliore la tol@'erance aux fautes du syst@`eme;
@item
si plusieurs @code{ResultRepository} sont pr@'esents, l'utilisation de 
requ@^etes du type @code{concurrentAsk}@footnote{voir l'API de Magique}
permet d'acc@'eder au @code{ResultRepository} le moins charg@'e, d'o@`u
une adaptation @`a la charge du syst@`eme.
@end enumerate

Les m@'ethodes accessibles du @code{ResultRepository} sont les suivantes:

@itemize @bullet
@item
@code{public void cleanUp()}: supprime tous les r@'esultats actuellement 
stock@'es;

@item
@code{public Set getResult(WrapperResult templateResult)}: renvoie tous les
objets stock@'es dans ce @code{ResultRepository} qui correspondent @`a celui
pass@'e en param@`etre;

@item
@code{public Set getAll()}: retourne tous les @'el@'ements contenus dans 
le @code{ResultRepository};

@item
@code{public void addResult(WrapperResult wrapperResult)}: ajoute le 
@code{Result} pass@'e en param@`etre dans le @code{ResultRepository};

@item
@code{public Boolean isStored(WrapperResult result)}: v@'erifie si un objet
est stock@'e dans le @code{ResultRepository};

@item
@code{public Integer numberOfElements()}: retourne le nombre total 
d'@'el@'ements contenus dans ce @code{ResultRepository}.
@end itemize

Nous allons maintenant expliquer le m@'ecanisme mis en oeuvre dans le 
@emph{framework} lorsqu'une t@^ache se termine.@

L'interface @code{Result} est la suivante:

@example
public interface Result extends Serializable @{
    public void put(Class fieldClass, String fieldName, Object fieldValue);    

    public Object get(Class fieldClass, String fieldName);
    
    public String[] keys();

    public String getTaskID();

    public void setTaskID(String id);

    public Result copy();
@}
@end example

Les deux m@'ethodes qui nous int@'eressent ici sont @code{put} et @code{get}. 
Le r@'esultat d'une t@^ache Rage est constitu@'e d'une partie des attributs
de sa classe. Ceux-ci sont ajout@'es dans le @code{Result} gr@^ace @`a la
m@'ethode @code{put} qui prend en param@`etre la classe, le nom et la valeur
de l'attribut. Tous les attributs de la t@^ache ne sont pas sauvegard@'es 
dans le @code{Result}. Par convention, la m@'ethode @code{getResult} de la 
classe @code{AbstractTask} ne sauvegarde que les attributs d@'eclar@'es 
publiques. 
Cette convention permet aux d@'eveloppeurs de s@'electionner les attributs
qu'ils veulent r@'ecup@'erer dans l'objet @code{Result}.@

Soit une classe d@'eclar@'ee comme suit:

@example
public class ResultExTask extends AbstractTask @{
        
    public Long longField;
    public String stringField;

    private Integer intField;     // ces deux champs ne sont
    protected Double doubleField; // pas sauvegardes dans le Result

    ...
@}
@end example 

On obtiendra le r@'esultat de cette t@^ache ainsi:

@example
ResultExTask task = new ResultExTask(...);
...
Result result = task.getResult();
@end example

Pour r@'ecup@'erer la valeur du champs @code{longField}, il suffit d'appeler
la m@'ethode @code{get} de l'objet @code{Result}:

@example
Long l = (Long) result.get(Long.class, "longField");
@end example

De mani@`ere identique, lorsque l'on r@'ecup@'ere un @code{Result} 
par une m@'ethode d'un @code{ResultRepository}, on proc@'ede de la m@^eme
mani@`ere:

@example
Set set = (Set) askNow("getAll"); // Recupere tous les resultats

for(Iterator it = set.iterator(); it.hasNext(); ) @{
        Result result = (Result) it.next();

        String s = (String) result.get(String.class, "stringField");
        ...
@}
@end example

L'impl@'ementation actuelle des @code{ResultRepository} repose sur 
@code{Db4o}@footnote{http://www.db4o.com}, un moteur de base de donn@'ee 
orient@'ee objets @'ecrit en Java. Ce moteur est l@'eger et 
g@`ere la persistance des donn@'ees. Il n'a cependant pas donn@'e enti@`ere
satisfaction et il est envisag@'e de le remplacer par une base de donn@'ee
via JDBC.

@subsection Le r@^ole RepositoriesManager

Le @code{RepositoriesManager} est responsable de la gestion des 
@code{ResultRepository}. Son r@^ole actuel se limite @`a la cr@'eation
d'un unique @code{ResultRepository} mais cette fonctionnalit@'e pourrait
@^etre compl@'et@'ee pour am@'eliorer les performances du syst@`eme.@
Typiquement, le @code{RepositoriesManager} pourrait surveiller les requ@^etes
qui sont faites aux @code{ResultRepository} pour pouvoir cr@'eer des 
accointances entre certains @code{ResultRepository} et les agents qui les
sollicitent beaucoup. Dans le cas o@`u les agents sont localis@'es sur des
r@'eseaux diff@'erents, il reviendrait au @code{RepositoriesManager} de 
prendre en charge la cr@'eation des @code{ResultRepository} pour limiter
le nombre de passerelles entre les @code{PlatformManager} et les 
@code{ResultRepository}.

@subsection Le r@^ole PlatformManager

Les @code{PlatformManager} sont responsables de la gestion des ressources
au niveau d'une plateforme au sens de Magique. Il g@`ere un @emph{pool} 
d'agents calculateurs et leur alloue les t@^aches au fur et @`a mesure
que ceux-ci terminent leur calcul.@

L'algorithme original faisait du @code{TaskDispatcher} l'initiateur de la 
distribution des t@^aches. Lorsqu'une nouvelle t@^ache @'etait d@'epos@'ee par
le @code{TaskManager}, une plateforme @'etait choisie dans l'ensemble des 
plateformes disponibles, puis la t@^ache @'etait envoy@'ee.@

Ce m@'ecanisme pr@'esente plusieurs d@'efauts : 
@itemize @bullet
@item
de nombreuses t@^aches sont cr@'e@'ees sur les @code{PlatformManager}, d'o@`u une 
consommation importante de ressources (il faut un thread par t@^ache) et
donc une d@'egradation des performances sur l'@'el@'ement assurant le calcul. 
De plus, cette cr@'eation est @emph{a priori} ind@'ependante de l'@'etat du syst@`eme 
abritant la plateforme. La distribution ne prend donc pas en compte
des crit@`eres comme la charge (qui peut varier au cours du temps) ou 
les capacit@'es de la machine; 
@item
une prise en charge correcte @emph{load-balancing}, si tent@'e qu'elle soit 
possible, pourrait se faire par l'emploi d'objets du type @code{Selector}
mais la prise en compte des diff@'erentes caract@'eristiques techniques 
des machines est un probl@`eme extr@^emement compliqu@'e qui d@'epend du 
mat@'eriel, du syst@`eme d'exploitation et de la charge (variable) @`a 
un moment donn@'e; 
@item
si une plateforme tombe, de nombreuses t@^aches sont perdues et le 
m@'ecanisme de @emph{timeout} mettra du temps avant de relancer les 
t@^aches. 
@end itemize

Pour rem@'edier @`a ces probl@`emes, un @emph{m@'ecanisme de r@'epartition 
implicite} a @'et@'e mis en place.@

L'id@'ee de l'algorithme est simple: il suffit que la distribution 
des t@^aches ne se fasse plus @`a l'initiative du @code{TaskDispatcher} mais plut@^ot 
@`a la demande des @code{PlatformManager} eux-m@^emes. Ainsi, les @code{PlatformManager} 
ne g@'erent qu'un nombre fixe de @code{ReckonerAgent} qui existent d@`es la 
cr@'eation du @code{PlatformManager}. Chaque agent calculateur se voit affecter 
une t@^ache, et d@`es que le calcul a @'et@'e men@'e @`a son terme, le 
@code{PlatformManager} demande une nouvelle t@^ache au @code{TaskDispatcher} 
et l'affecte @`a l'agent libre. Les avantages de ce m@'ecanisme sont : 

@itemize @bullet
@item
la r@'esolution du probl@`eme d'adaptation @`a une charge de travail 
variable (au cours du temps et selon l'utilisation qu'il est faite 
de la machine abritant la plateforme). En effet, si la charge de 
la machine augmente, le temps de calcul des diff@'erentes t@^aches 
va s'accroitre et la machine demandera moins de t@^ache. On @'evitera 
ainsi une surcharge pr@'ejudiciable. Inversement, si la machine est 
peu charg@'ee, elle terminera plus vite le calcul de ses t@^aches et pourra 
donc en demander beaucoup. Chaque plateforme s'adapte donc 
naturellement @`a sa propre charge; 
@item
une plus grande s@'ecurit@'e puisque le nombre de t@^aches s'ex@'ecutant 
sur une machine donn@'ee est moindre. Cependant, le m@'ecanisme de 
@emph{timeout} est conserv@'e; 
@item
la possibilit@'e d'ajouter ou de retirer des @code{PlatformManager} 
"@`a la vol@'ee".
@end itemize

Les m@'ethodes accessibles du @code{PlatformManager} sont les suivantes:

@itemize @bullet
@item
@code{public void killTask(Object cond)}: stopper les t@^aches qui r@'epondent
@`a la condition pass@'ee en param@'etre;
@item   
@code{public void setNumberOfAgents(Integer numAgents)}: fixe le nombre
d'agents calculateurs sur cette plateforme;
@item
@code{public Integer getNumberOfAgents()}: retourne le nombre d'agents 
calculateurs disponibles sur cette plateforme.
@end itemize

@subsection Le r@^ole ReckonerAgent

Ces agents sont les entit@'es responsables des calculs. Ils re@,{c}oivent les 
t@^aches des @code{PlatformManager}, ex@'ecutent le calcul puis envoient 
le r@'esultat vers un @code{ResultRepository}. De plus, il permettent aux 
t@^aches de b@'en@'eficier du support de communication du syst@`eme 
multi-agents. 
Les m@'ethodes accessibles sont les suivantes:

@itemize @bullet
@item
@code{public Boolean setTask(WrapperTask wrapperTask)}: fixe la t@^ache de 
l'agent. Renvoie @code{Boolean.TRUE} si l'affectation a r@'eussi (@emph{i.e.}
si l'appel @`a @code{Task.init()} s'est correctement d@'eroul@'e);

@item
@code{public Boolean isTaskFinished()}: renvoie @code{Boolean.TRUE} si la 
t@^ache actuellement g@'er@'ee est termin@'ee (@code{i.e.} si l'appel 
@`a @code{Task.finished()} renvoie @code{true});

@item
@code{public void killTask(Object cond)}:
teste si la t@^ache doit se terminer et le cas @'ech@'eant, arr@^ete la 
t@^ache (cette m@'ethode ex@'ecute en fait: @code{si Task.mustDie(cond) alors 
Task.die()}).
@end itemize

@c -------------------------------------------------- Chapitre 3

@chapter Applications

@c --------------------------- PI

@section Calcul probabiliste de Pi

Il s'agit ici d'un exemple qui se veut assez simple et qui constitue 
ainsi un moyen d'appr@'ehender Rage pour la premi@`ere fois.
L'algorithme se d@'eroule en une seule phase et les t@^aches sont
totalement ind@'ependantes les unes des autres. 

@subsection Algorithme

Cette application cherche @`a approcher la valeur de Pi par une 
m@'ethode probabiliste.@

Le principe est assez simple. Consid@'erons un carr@'e dont la longueur du 
c@^ot@'e vaut 1, ainsi que le quart de cercle inscrit dans ce carr@'e et dont 
le centre est confondu avec l'un des sommets du carr@'e:

@image{carre, 5cm, }

Si l'on tire un point au hasard @`a l'int@'erieur du carr@'e, la probabilit@'e
que ce point se trouve @`a l'int@'erieur du quart de cercle est @'egale 
au quotient de la surface du quart de cercle et de la surface du carr@'e. Par
simplication, on trouve:

@center @emph{p} = PI / 4

Si @emph{p'} est une valeur approch@'ee de @emph{p}, on aura donc

@center PI = @emph{p'} x 4

L'application consiste donc @`a tirer des points @`a l'int@'erieur du carr@'e
et @`a comptabiliser ceux qui se trouve @`a l'int@'erieur du quart de cercle.
Si on note @emph{N} le nombre total de points tir@'{e}s et @emph{I} le nombre
de points qui se trouvaient @`a l'int@'erieur du quart de cercle, on obtiendra
alors:

@center @emph{p'} = I / N

Soit, la valeur approch@'ee de PI

@center PI = 4 x I / N

La valeur approch@'ee sera d'autant meilleure que le nombre de points tir@'{e}s
sera @'elev@'e (th@'eor@'eme de Bernouilli: on sait que dans une s@'erie 
d'@'epreuves ind@'ependantes, la fr@'equence relative de l'@'ev@'enement 
@emph{A} converge en probabilit@'e vers @emph{P(A)} quand le nombre 
d'@'epreuves croit ind@'efiniment).@

L'int@^eret du syst@`eme distribu@'e sera alors mis @`a profit en utilisant
un grand nombre d'agents et en prenant comme r@'esultat final la moyenne de
tous les r@'esultats.

@subsection @code{PiTask}

Les t@^aches sont tr@`es simples  @`a @'ecrire. Elles ne font que suivre 
exactement l'algorithme d@'ecrit ci-dessus. La fonction @code{compute} est la 
suivante:

@example
public class PiTask extends AbstractTask @{

    public Double pi;

    private int nb = 1000;    
    private int total;
    private int inner;    

    public PiTask(String factoryId, String taskId) @{
        super(factoryId, taskId);

        total = 0;
        inner = 0;
    @}

    ...

    public void compute() @{
        double x, y, tmp;
	
        while(nb != 0) @{
            x = Math.random();
            y = Math.random();

            if (java.lang.Math.sqrt(x*x + y*y) <= 1.0)
                  inner ++;
	    
            total ++;
            nb --;
        @}

        tmp = (double)inner / (double)total;
        tmp *= 4;

        pi = new Double(tmp);

        System.out.println(getTaskID() + ": PI = " + tmp);
    @}
@}
@end example

Comme on peut le voir ci-dessus, le seul attribut d@'eclar@'e @code{public} est 
l'objet @code{pi} de type @code{Double}. Ce sera donc le seul champs
sauvegard@'e dans le r@'esultat de la t@^ache. 
Le seul param@`etre pouvant varier au niveau des t@^aches est le nombre 
d'it@'erations @`a effectuer.

@subsection @code{PiFactory}

La @code{TaskFactory} de cet exemple est vraiment tr@'es simple puisqu'elle
fournit des t@^aches @`a la demande, sans jamais s'arr@^eter. Voici le code:

@example
public class PiFactory implements TaskFactory @{
    
    private String factoryID;
    private static int counter = 0;

    public PiFactory() @{
        this.factoryID = "PiFactory";
    @}

    public String getFactoryID() @{
        return factoryID;
    @}

    public boolean hasNext() @{
        return true;
    @}

    public Task next() @{
        PiTask task = new PiTask(factoryID, "PiTask" + counter++);
        return task;
    @}  
@}
@end example

@subsection @code{PiAgentSkill}

L'agent g@'erant le calcul de Pi dispose de deux comp@'etences.
La premi@`ere permet de d@'emarrer le calcul et la seconde sert @`a 
r@'ecup@'erer les r@'esultats au cours du calcul.

@subsubsection @code{startPiAgentSkill}

Voici le code de cette comp@'etence:

@example
    public void startPiAgentSkill(Integer n) @{
        factory = new PiFactory();

        new PiAgentThread(n.intValue()).start();

        System.out.println("PiAgent thread launched for " + 
                           n.intValue() + " tasks.") ;
    @}
@end example

On commence par cr@'eer la @code{Factory}, puis on lance un @emph{thread} qui
se charge de demander les t@^aches @`a cette @code{Factory} pour les 
d@'eposer dans le @code{TaskDispatcher}: 

@example
    class PiAgentThread extends Thread @{
	
        private int numTask;
	
        public PiAgentThread(int numTask) @{
            this.numTask = numTask;
        @}
	
        public void run() @{
            int n = 0;

            System.out.println("Dispatch " + 
                               numTask + 
                               " tasks ...");

            while(n < numTask) @{
                // No need to check if there is more task
                // (see PiFactory code)
                Task t = factory.next();
		
                perform("addNewTask", 
                        new Object[] @{new WrapperTask(t)@});
                n ++;		    
            @}
	    
            System.out.println(n + " tasks dispatched.");
        @}   
    @}
@end example

@subsubsection @code{getPiResult}

Cette comp@'etence se charge de r@'ecup@'erer les r@'esultats d@'ej@`a 
calcul@'es et d'en faire la moyenne. Le code:

@example
    public void getPiResult() @{
        Set theResults = (Set) askNow("getAll");
        int nres = theResults.size();
        double pi = 0;

        if (nres == 0) @{
            gui.setInfo("No result found in repository");
            return;
        @}

        gui.setInfo(nres + " results found");
	
        Iterator it = theResults.iterator();
        while(it.hasNext()) @{
            Result res = (Result) it.next();
	    	    
            Double d = (Double) res.get(Double.class, "pi");
            pi = pi + d.doubleValue();
        @}

        pi = pi / nres;
        gui.setInfo("Result PI = " + pi);
   @}
@end example

La comp@'etence se d@'eroule en deux phases:
@enumerate
@item
v@'erifier le nombre de @code{Result} dans le @code{ResultRepository} en les
r@'ecup@'erant tous;

@item
si le nombre de @code{Result} n'est pas nul, calculer la moyenne des 
r@'esultats et pr@'esenter le r@'esultat.
@end enumerate

@c --------------------------- Ane rouge

@section Les jeux de taquins

Les jeux de taquins (sliding blocks) sont des puzzles dans lesquels il faut 
d@'eplacer des pi@`eces pour les amener @`a former une figure particuli@`ere. 
Ces jeux se caract@'erisent par l'utilisation d'un plateau sur lequel on 
dispose un ensemble de pi@`eces pouvant se d@'eplacer. Les taquins monoformes 
sont tr@`es r@'epandus et consistent la plupart du temps @`a reconstituer une
image qui est dessin@'ee sur les pi@`eces. Par contre, les taquins multiformes 
(c'est-@`a-dire constitu@'es de pi@`eces de diff@'erentes formes) sont beaucoup
plus rares et aussi beaucoup plus difficiles @`a r@'esoudre. 

Quel peut @^etre l'utilit@'e d'aborder l'analyse des jeux de taquins de 
mani@`ere syst@'ematique en recourant @`a l'informatique ?@

Dans un premier temps cela permet au joueur de d@'eterminer le ou les plus 
courts chemins pour r@'esoudre le taquin. Dans un second temps cela permet de 
d@'ecouvrir les structures math@'ematiques sous-jacente @`a ses jeux. 
Ainsi, on peut voir les jeux de taquins comme un jeu d'orientation au sein d'un
graphe implicite. En effet, en imaginant qu'un noeud repr@'esente une @'etat du
jeu et qu'un arc repr@'esente le d@'eplacement d'une des pi@`eces, la structure
du jeu est un graphe. Un @'enorme graphe d'ailleurs: par exemple celui de l'@^ane 
rouge (en partant de la position initiale 'historique') est 
constitu@'e d'environ de 25955 @'etats ! Il est difficile d'imaginer la 
complexit@'e structurelle provoqu@'ee par les contraintes physiques impos@'ees 
par le plateau et les pi@`eces. On d@'ecouvre ainsi un nouvel int@'eret @`a 
cette @'etude : caract@'eriser l'int@'er@^et d'un jeu par des propri@'et@'es 
relatives au graphe le repr@'esentant.@

Le but de cette @'etude est donc de d@'eterminer les crit@`eres qui 
permettraient de g@'en@'erer automatiquement des jeux de taquins multiformes 
et de s@'electionner ensuite ceux qui sont les plus int@'eressants. Pour cela 
nous nous sommes d'abord concentr@'e sur l'@'etude du jeu de l'Ane Rouge. 

@subsection Description

Le jeu de l'Ane Rouge est un jeu de taquin constitu@'e de pi@`eces multiformes. 
Contrairement aux taquins habituels, dans l'Ane Rouge il a des pi@`eces de formes
diff@'erentes. Plus particuli@`erement, la plus grosse pi@`ece (b) repr@'esente l'Ane 
Rouge, et le but du jeu consiste @`a l'amener @`a la place des quatres plus 
petites pi@`eces (e) de la position initiale.
L'int@'er@^et de cet exemple est qu'il se compose de deux phases distinctes. La 
premi@`ere phase calcule un ensemble d'@'etats et teste leur validit@'e. Elle permet 
en outre d'@'eliminer un grand nombre d'@'etats invalides et donc de soulager la
seconde phase qui consiste @`a effectuer le calcul des graphes dont les @'etats de d@'eparts
sont pris parmi les @'etats valides d@'etermin@'es @`a l'@'etape pr@'ec@'edente. De plus, on 
cherche @`a optimiser la charge en arr@^etant les t@^aches qui se r@'ev@'elent inutiles
au fur et @`a mesure que le calcul des graphes avance.@

Le jeu de l'Ane Rouge est constitu@'e d'un plateau rectangulaire de 4x5 unit@'es,
et de 10 pi@`eces : 
@itemize @bullet
@item
1 pi@`ece 2x2, repr@'esentant l'Ane Rouge 
@item
1 pi@`ece 2x1 
@item
4 pi@`eces 1x2 
@item
4 pi@`eces 1x1 
@end itemize

Ce qui nous laisse deux emplacements vides sur le plateau qui nous permettent
de d@'eplacer les pi@`eces.@

L'image ci-dessous repr@'esente la position initiale du plateau de jeu de l'Ane
Rouge:

@image{board, 6cm, }

Pour pouvoir @'etudier le graphe constitu@'e par ce plateau et ces  pi@`eces, il est
n@'ecessaire de mod@'eliser le jeu, c'est-@`a-dire de convenir d'une repr@'esentation
des @'el@'ements du jeu (plateau, pi@`eces) et des r@`egles du jeu (gestion des
d@'eplacements).@

Pour cela, nous avons @'elabor@'e un codage nous permettant de repr@'esenter
l'@'etat du plateau par un mot (une chaine de caract@`eres). Pour d@'ecrire une 
position particuli@`ere du jeu, nous commen@,{c}ons par @'etiquetter chaque pi@`ece 
par une lettre, par exemple si nous lisons les lettres en partant du coin 
sup@'erieur gauche jusqu'au coin inf@'erieur droit, nous obtenons un mot codant 
cette position : "@strong{abacdcaeeaee}". Ce codage est pratique puisqu'il 
nous permettra de g@'en@'erer facilement tous les @'etats possibles du jeu en 
g@'en@'erant l'ensemble des permutations de ce mot. Cependant, parmi ces mots 
se trouveront des doublons (puisqu'il existe des pi@`eces identiques) et 
des @'etats invalides (i.e. ne repr@'esentant pas un @'etat valide du jeu, 
lorsqu'en d@'ecodant le mot des pi@`eces "sortent" du plateau). 

@subsection Algorithme

L'algorithme g@'en@'eral permettant d'@'etudier les jeux de taquin multiformes est 
constitu@'e de trois phases : 

@enumerate
@item
La premi@`ere phase consiste @`a g@'en@'erer l'ensemble des @'etats valides du jeu. 
C'est-@`a-dire les mots repr@'esentant les @'etats du jeu dans lesquels toutes 
les pi@`eces tiennent @`a l'int@'erieur du plateau. 
@item   
La seconde phase consiste @`a reconstituer les diff@'erents graphes du jeu. 
En effet, avec le meme plateau et les memes pi@`eces, il est g@'en@'eralement
possible d'obtenir des graphes non connexes (c'est le fameux exemple du 
taquin monoforme 14-15). 
@item
La troisi@`eme phase consiste enfin @`a appliquer les heuristiques qui nous 
donneront une mesure de l'int@'eret du jeu. 
@end enumerate

Actuellement, l'algorithme impl@'ement@'e avec Rage ne prend en compte que les 
deux premi@`eres phases. 

@subsubsection Phase 1: g@'en@'eration de l'ensemble des @'etats valides

La premi@`ere phase consiste @`a calculer la totalit@'e des @'etats valides 
@`a partir desquels on calculera l'ensemble des graphes. Cet ensemble 
d'@'etats ne doit donc pas contenir de doublons. On fournit donc deux 
bornes @`a chaque t@^ache. Celles-ci correspondent au rang inf@'erieur et 
sup@'erieur des permutations @`a g@'en@'erer et @`a valider. 
La t@^ache g@'en@'ere donc les permutations et v@'erifie pour chacune qu'elle 
correspond @`a un @'etat valide (i.e. qui tient dans le plateau) puis, si 
elle n'est pas d@'ej@`a connue, l'ajoute @`a son ensemble d'@'etats valides. 
L'ensemble des positions est ensuite r@'ecup@'er@'e au niveau du @code{TaskManager}. 
On remarquera que, les t@^aches ne testant qu'un nombre restreint de 
permutations, il restera des doublons parmi les @'etats valides 
calcul@'es par des t@^aches diff@'erentes. Le manager devra donc @'eliminer 
ces doublons.@

Cette phase permet d'@'eliminer un grand nombre d'@'etats @`a tester. 
Prenons l'exemple du mot @strong{"abacdcaeeaee"}. Comme il est constitu@'e de 
12 pi@`eces, nous avons 12! = 479 001 600 permutations. En @'eliminant les 
doublons, le nombre de mots tombe @`a 
(12!)/(4! x 2! x 4 !) = 415 800 soit environ 1000 fois moins. En
@'eliminant encore les mots ne repr@'esentants pas un @'etat valide, 
c'est-@`a-dire ne pouvant tenir dans le plateau, le nombre atteint 
approximativement 65880 @'etats. 
Soit finalement environ 7000 fois moins d'@'etats @`a tester.
Une fois l'ensemble des @'etats valides connus, il est possible de 
passer @`a la seconde phase : la g@'en@'eration des graphes repr@'esentants 
les diff@'erents jeux. 

@subsubsection Phase 2: g@'en@'eration de l'ensemble des graphes 

La seconde phase consiste en la g@'en@'eration des graphes. 
La premi@`ere phase a permis d'@'eliminer un grand nombre d'@'etats. 
Chaque t@^ache re@,{c}oit un @'etat de d@'epart, une graine, puis calcule 
le graphe des @'etats pouvant @^etre atteints (@emph{i.e.} la cl@^oture 
du graphe) @`a partir de cette graine. Le graphe r@'esultant est
stock@'e dans le @code{RepositoryManager}. 
Lorsqu'un nouveau graphe est stock@'e, le @code{TaskManager} examine 
tous les @'etats qu'il contient ce qui lui permet d'arr@^eter les t@^aches
dont l'@'etat de d@'epart a @'et@'e visit@'e lors du calcul d'un autre graphe. 
En effet, deux taches initiant leur calcul avec une graine diff@'erente 
peuvent en fait @^etre en train de g@'en@'erer le m@^eme graphe. 
Il est alors important de stopper ces t@^ches effectuant des calculs 
redondants. 

@subsubsection Phase 3 : Application des diff@'erentes heuristiques caract@'erisant l'int@'er@^et d'un graphe 

Cette derni@`ere phase n'est pas impl@'ement@'ee pour l'instant. 
Cependant, on soup@,{c}onne que l'int@'eret d'un jeu provient non 
seulement de la taille du graphe, mais aussi de sa topologie. 
On suppose en effet que le graphe du jeu de l'Ane Rouge est 
constitu@'e de "grosses" composantes fortement connexes, et que 
le nombre de passage d'une "grosse" composante @`a l'autre est 
relativement restreint. Pour v@'erifier cette hypoth@`ese, il faut 
trouver un algorithme permettant de d@'eterminer le nombre de 
"grosses" composantes et @'eventuellement de rep@'erer aussi les
"ponts", c'est-@`a-dire les @'etats constituants les passages entre 
les composantes.@

Un algorithme actuellement @`a l'@'etude serait de tirer al@'eatoirement 
deux @'etats d'un graphe et de calculer les chemins les plus courts 
pour aller d'un @'etat @`a l'autre. Le long de ces chemins, il faudrait 
alors incr@'ementer un compteur pour chaque noeud travers@'e. On 
recommence un grand nombre de fois ces op@'erations. Ensuite, on rep@`ere 
les noeuds dont le compteur est le plus @'elev@'e et il est problable 
que cela soit des "ponts". 

@c --------------------------- TWODD

@section  M@'ethode des discontinuit@'es de d@'eplacement (TWODD)

@subsection Introduction. 

Beaucoup de probl@`emes de m@'ecanique des solides impliquent des 
corps contenant de petites cavit@'es : des fissures. Une fissure 
est constitu@'ee de deux surfaces ou fronti@`eres, l'une coincidant 
avec l'autre, sur laquelle le champs de d@'eplacement est discontinu. 
Une m@'ethode reposant sur les @'el@'ements finis peut etre employ@'ee 
pour de tels cas. Cette m@'ethode appel@'ee m@'ethode de discontinuit@'es 
de d@'eplacement est bas@'e sur la solution analytique du probl@`eme relatif 
@`a une discontinuit@'e de d@'eplacement constant le long d'un segment
fini dans le plan (x,y) d'un solide @'elastique infini. 
Elle aboutit @`a un syst@`eme d'@'equations lin@'eaires, impliquant une matrice
carr@'e dite d'influence. 

@subsection Description. 

Le but est donc de calculer la matrice d'influences qui nous 
permettra de d@'eterminer les discontinuit@'es de d@'eplacement en 
n'importe quel point du milieu. 
Une premi@`ere partie consiste @`a d@'efinir le milieu, les forces impos@'ees. 
Ensuite il faut discr@'etiser ce milieu avant de pouvoir commencer les calculs.

@subsection Algorithme. 

L'algorithme est constitu@'e de trois phases successives : 
La discr@'etisation du milieu (i.e. calcul des points, de la longueur 
des segments, des vecteurs normaux et r@'epartition des forces impos@'ees). 
Le calcul des coefficients de la matrice d'influence B. 
La r@'esolution du syst@`eme B . D = F (ou B est la matrice d'influences, 
D le vecteur de discontinuit@'e de d@'eplacement et F le vecteur de 
forces impos@'ees). 
La premi@`ere et la derni@`ere phase n'@'etant pas trop co@^uteuses en termes 
de calculs, elles ne sont donc pas distribu@'ees @`a l'aide de Rage. 
Par contre, les calculs des coefficients de la matrice d'influences 
sont r@'epartis. 

@subsubsection Phase 1 : Discr@'etisation du milieu (calcul non distribu@'e). 

Un petit @'editeur graphique a @'et@'e r@'ealis@'e dans le but de pouvoir saisir 
rapidement la g@'eom@'etrie d'un milieu, et de fixer les param@`etres tels que 
les forces impos@'ees ainsi que le niveau de discr@'etisation. 
Cet outil g@'en@'ere les donn@'ees n@'ecessaires @`a la construction de la matrice. 

@image{editeur, 15cm, }

@subsubsection Phase 2 : Calcul de la matrice d'influence et de d@'eplacement (calcul distribu@'e). 

Le calcul de la matrice d'influence consiste pour chaque point soumis 
@`a une force @`a effectuer un calcul relatif @`a l'ensemble des autres
points. L'algorithme consiste donc @`a effectuer deux boucles 
imbriqu@'ees sur l'ensemble des points. La distribution sous forme 
de t@^aches peut alors se faire ainsi : chaque t@^ache repr@'esente une 
partie de la boucle englobante.

@subsubsection Phase 3 : R@'esolution du syst@`eme B. D = F (calcul non distribu@'e). 

A la fin de la deuxi@`eme phase, on dispose de la matrice d'influence B, 
il nous reste @`a r@'esoudre le syst@`eme d'@'equations lin@'eaires B . V = F. 
Pour la r@'esolution de ce syst@`eme nous utilisons la librairie 
math@'ematique COLT d@'evelopp@'ee par le CERN, qui dispose de types et 
d'op@'erateurs d'alg@`ebre lin@'eaire.

@subsubsection Evaluation quantitative. 

Il existait un programme FORTRAN impl@'ementant cette m@'ethode 
(non r@'eparti). 
Nous l'utiliserons pour @'evaluer l'apport de Rage en terme de vitesse 
de calcul et de mont@'ee en puissance 
(augmentation du niveau de discr@'etisation). 

@contents
@bye
